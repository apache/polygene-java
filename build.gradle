title = "Qi4j SDK"
description = "Qi4jâ„¢ is a framework for domain centric application development, including evolved concepts from AOP, DI and DDD."

apply plugin: 'java'
apply from: 'maven-compat.gradle'
apply plugin: 'project-report'
apply from: 'libraries.gradle'

targetCompatibility = "1.6"
sourceCompatibility = "1.6"

testFailures = false

groovycMain_mx = "512m"
groovycMain_permSize = "64m"
groovycMain_maxPermSize = "128m"

// Collect the modules that fulfills the Release Criteria.
project.releaseSpec = new ModuleReleaseSpecification()
def releaseApprovedProjects = allprojects.findAll({ project ->  rootProject.releaseSpec.satisfiedBy(project) })

allprojects {
  apply plugin: 'eclipse'
  apply plugin: 'idea'
  apply plugin: 'java'
  apply plugin: 'code-quality'
  apply plugin: 'project-report'

  project.Xslt = Xslt.class

  group = name.substring(0, name.lastIndexOf('.'))
  defaultTasks 'build'
  version = System.properties.version ?: "1.3-SNAPSHOT"
  idea.javaVersion = '1.6'
  [compileJava, compileTestJava]*.options*.encoding = 'UTF-8'

  repositories {
    mavenCentral()
    mavenRepo name: 'ops4j-repo', urls: "http://repository.ops4j.org/maven2/"
  }

  dependencies {
    testCompile("org.apache.ant:ant:$antVersion")
    testCompile("org.apache.ant:ant-junit:$antVersion")
    testCompile('junit:junit:4.8.1')
    testRuntime('net.sourceforge.cobertura:cobertura:1.9.3')
    testRuntime("asm:asm:$asmVersion", "asm:asm-util:$asmVersion", "asm:asm-commons:$asmVersion")
  }

  configurations {
    deployerJars
    provided
    compile.extendsFrom provided
  }

  dependencies {
    deployerJars "org.apache.maven.wagon:wagon-ssh:1.0-beta-2"
  }

  javaDir = new File("$projectDir/src/main/java")
  testDir = new File("$projectDir/src/test/java")

  if( javaDir.isDirectory() || testDir.isDirectory() )
  {
    apply plugin: 'osgi'
    apply plugin: VersionClass
    apply plugin: 'code-quality'

    if( name == "org.qi4j.core.runtime" )
    {
      checkstyleMain {
        configFile = new File("$rootProject.projectDir.absolutePath/etc/qi4j-runtime-checkstyle.xml")
        ignoreFailures = true
      }
    }
    else
    {
      checkstyleMain {
        configFile = new File("$rootProject.projectDir.absolutePath/etc/qi4j-api-checkstyle.xml")
        ignoreFailures = true
      }
    }
    checkstyleTest {
      configFile = new File("$rootProject.projectDir.absolutePath/etc/qi4j-tests-checkstyle.xml")
      ignoreFailures = true
    }

    checkstyleVersion {
      configFile = new File("$rootProject.projectDir.absolutePath/etc/qi4j-tests-checkstyle.xml")
      ignoreFailures = true
    }

    jar {
      manifest {
        license = 'http://www.apache.org/licenses/LICENSE-2.0.txt'
        docURL = 'http://www.qi4j.org'
        description = project.description ?: 'Qi4j is a platform for Composite Oriented Programming'
        vendor = 'Qi4j Community, http://www.qi4j.org'
        instruction '-debug', 'true'
      }
    }

    task sourceJar(type: Jar) {
      classifier = "sources"
      from sourceSets.main.allSource
      into configurations.archives
    }

    artifacts {
      archives sourceJar
    }

    def cobSerFile = "${project.buildDir}/coverage/cobertura.ser"
    def srcOriginal = "${sourceSets.main.classesDir}"
    def srcCopy = "${srcOriginal}-copy"

    test.doFirst {
      ant {
        // delete data file for cobertura, otherwise coverage would be added
        delete(file: cobSerFile, failonerror: false)
        // delete copy of original classes
        delete(dir: srcCopy, failonerror: false)
        // import cobertura task, so it is available in the script
        taskdef(resource: 'tasks.properties', classpath: configurations.testRuntime.asPath)
        // create copy (backup) of original class files
        copy(todir: srcCopy) {
          fileset(dir: srcOriginal)
        }
        // instrument the relevant classes in-place
        'cobertura-instrument'(datafile: cobSerFile) {
          fileset(dir: srcOriginal,
                  includes: "org/qi4j/**/*.class",
                  excludes: "**/*Test.class")
        }
      }
    }

    test.doLast {
      if( new File(srcCopy).exists() )
      {
        def gradleProject = project
        def rootCobSerFile = "${rootProject.buildDir}/coverage/cobertura.ser"

        // replace instrumented classes with backup copy again
        ant {
          delete(file: srcOriginal)
          move(file: srcCopy, tofile: srcOriginal)

          taskdef(name: 'coberturaMerge',
                  classname: 'net.sourceforge.cobertura.ant.MergeTask',
                  classpath: configurations.testRuntime.asPath)

          coberturaMerge(datafile: rootCobSerFile) {

            if( file("${gradleProject.buildDir}/coverage/cobertura.ser").exists() )
            {

              fileset(dir: gradleProject.buildDir, includes: 'coverage/cobertura.ser')
            }
          }
        }
      }
    }

    def testProperties = [
            'proxySet': System.properties[ 'proxySet' ],
            'proxyHost': System.properties[ 'proxyHost' ],
            'proxyPort': System.properties[ 'proxyPort' ]]

    test {
      maxHeapSize = "1024m"
      systemProperties = testProperties
      systemProperties[ "net.sourceforge.cobertura.datafile" ] = cobSerFile
      ignoreFailures = true
      afterSuite { descriptor, result ->
        if( result.testCount != result.successfulTestCount )
        {
          rootProject.testFailures = true
        }
      }
    }

    // Create checkstyle report
    task checkstyleReport(type: Xslt, dependsOn: check) {
      source project.checkstyleResultsDir
      include '*.xml'
      destDir = file("build/reports/checkstyle/")
      extension = 'html'
      stylesheetFile = file("$rootProject.projectDir/etc/checkstyle-noframes.xsl")
    }

  }

  uploadArchives.doFirst {
    if( System.properties[ 'version' ] == null )
    {
      throw new GradleException("'version' must be given as a system property to perform a release.")
    }
  }

  uploadArchives.onlyIf { releaseApprovedProjects.contains(project)}
  uploadArchives {
    dependsOn check
    repositories.mavenDeployer {
      name = 'sshDeployer' // optional
      configuration = configurations.deployerJars
      repository(url: "scp://repository.ops4j.org/home/www/repository.ops4j.org/maven2/")
    }
  }

  ideaModule {
    whenConfigured { module ->
      module.dependencies*.exported = true
    }
  }


  dependsOnChildren()
}

test.doLast() {
//task genReport {
  def cobSerFile = "${project.buildDir}/coverage/cobertura.ser"
  ant {
    taskdef(name: 'coberturaReport',
            classname: 'net.sourceforge.cobertura.ant.ReportTask',
            classpath: configurations.testRuntime.asPath)

    // create cobertura report
    coberturaReport(destdir: buildDirName + "/reports/cobertura", format: 'html', datafile: cobSerFile) {
      allprojects.each { module ->
        if( rootProject != module )
        {
          if( file("$module.projectDir.absolutePath/src/main/java").exists() )
          {
            fileset(dir: "$module.projectDir.absolutePath/src/main/java") {
              include(name: '**/*.java')
            }
          }
        }
      }
    }

    taskdef(name: 'junitreport',
            classname: 'org.apache.tools.ant.taskdefs.optional.junit.XMLResultAggregator',
            classpath: configurations.testRuntime.asPath)

    // create Junit report
    def junitReportDir = buildDirName + "/reports/junit"
    mkdir(dir: junitReportDir)
    mkdir(dir: buildDirName + "/test-results")
    junitreport(todir: junitReportDir) {
      report(format: 'frames', todir: junitReportDir)
      allprojects.each { module ->
        fileset(dir: "$module.buildDir/test-results") {
          include(name: "TEST-*.xml")
        }
      }
    }

  }
}

task javadocs(type: Javadoc) {

  options.docFilesSubDirs = true
  title = "${rootProject.title} ${version}"
  def apiSources = releaseApprovedProjects.findAll({ project ->
    (project.name.startsWith('org.qi4j.core') &&
     !project.name.startsWith('org.qi4j.core.runtime')) ||
    project.name.startsWith('org.qi4j.library') ||
    project.name.startsWith('org.qi4j.extension')
  })
  source apiSources.collect { project ->
    project.sourceSets.main.allJava
  }
  destinationDir = new File("$buildDir/javadocs")
  // Might need a classpath
  classpath = files(apiSources.collect { project ->
    project.sourceSets.main.compileClasspath
  })
  options.links("http://java.sun.com/j2se/1.6.0/docs/api")
  options.group(["Core API": ["org.qi4j.api", "org.qi4j.api.*"],
                "Core Bootstrap": ["org.qi4j.bootstrap"],
                "Core SPI": ["org.qi4j.spi", "org.qi4j.spi.*"],
                "Libraries": ["org.qi4j.library.*", "org.qi4j.logging", "org.qi4j.logging.*", "org.qi4j.scripting.*"],
                "Extensions": ["org.qi4j.entitystore.*", "org.qi4j.index.*", "org.qi4j.cache.*", "org.qi4j.migration", "org.qi4j.migration.*"],
                "Test Support": ["org.qi4j.test", "org.qi4j.test.*"],

                ])

}

task distLayout {
  srcDistImage = copySpec {
    from '.'
    exclude '**/build/'     // build output
    exclude '**/.git/'      // git directories
    exclude '**/.git*'      // git files
    exclude '**/.gradle/'   // gradle management files
    into "qi4j-sdk-$version/src/"
  }


  docsImage = copySpec {
    into("docs")
    from "$buildDir/docs"
  }
  reportsImage = copySpec {
    into("docs/reports")
    from "$buildDir/reports"
  }
  javadocsImage = copySpec {
    into("javadocs")
    from "$buildDir/javadocs"
  }
  libsImage = copySpec {
    releaseApprovedProjects.collect { project ->
      if( project.group == 'org.qi4j.core' )
      {
        from project.configurations.runtime
        into("libs/core")
      }
      else if( project.group == 'org.qi4j.library' )
      {
        from project.configurations.runtime
        into("libs/libraries/$project.name")
      }
      else if( project.group == 'org.qi4j.extension' )
      {
        from project.configurations.runtime
        into("libs/extensions/$project.name")
      }
    }
  }
  samplesImage = copySpec {
    into("samples")
    from "$projectDir/samples"
    exclude '**/build'
    exclude '**/*.iml'
  }
  tutorialsImage = copySpec {
    into("tutorials")
    from "$projectDir/tutorials"
  }
  binDistImage = copySpec {
    into "qi4j-sdk-$version"
    with docsImage
    with reportsImage
    with javadocsImage
    with libsImage
    with samplesImage
    with tutorialsImage
  }
}

task zipSources(type: Zip) {
  baseName='qi4j-sdk'
  with distLayout.srcDistImage
  classifier = 'src'
}

task tarSources(type: Tar) {
  baseName='qi4j-sdk'
  with distLayout.srcDistImage
  compression = Compression.GZIP
  classifier = 'src'
}

task zipBinaries(type: Zip, dependsOn: [javadocs, test, distLayout]) {
  baseName='qi4j-sdk'
  classifier = 'bin'
  with distLayout.binDistImage
}

task tarBinaries(type: Tar, dependsOn: [javadocs, test, distLayout]) {
  baseName='qi4j-sdk'
  classifier = 'bin'
  compression = Compression.GZIP
  with distLayout.binDistImage
}

task release {
  description = 'Builds, tests and uploads the release artifacts'
  group = 'release'
  doFirst {
    if( System.properties[ 'version' ] == null )
    {
      throw new GradleException("'version' must be given as a system property to perform a release.")
    }
  }
  dependsOn allprojects*.uploadArchives
  dependsOn tarBinaries
  dependsOn zipBinaries
  dependsOn tarSources
  dependsOn zipSources
}

//
// This is a task that generates the gradlew scripts, allowing users to run gradle without having gradle installed
// on their system.
// This task should be run by "build master" and the resulting ouput committed to source control.  Its outputs include:
//  1) /gradlew which is the *NIX shell script for executing builds
//  2) /gradlew.bat which is the windows bat script for for executing builds
//  3) /wrapper which is a directory named by the "jarPath" config which contains other needed files.
task wrapper(type: Wrapper) {
  gradleVersion = '1.0-milestone-1'
  jarPath = 'wrapper'
}
